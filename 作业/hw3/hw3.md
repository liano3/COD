# 计算机组成原理

## 作业三

### T1

> 假设寄存器 t0 中初始状态下保存的值为 0x00002023。请回答下面的问题: 
>
> 1. 对于指令 sub t2, t0, t1, 导致结果溢出的 t1 的值的范围？ 
> 1. 假设 PC（程序计数器）当前值为 0x0D000000, 则 jal 指令可以到达的地址范围是多少？如果是 blt 呢？

##### (1)

t0 为正数，所以不可能是下溢出。

若为上溢出，则 t1 = -(0x7fffffff - 0x00002023) - 1 = 0x80002023

所以 t1 范围为 $[0x80000000, 0x80002023]$

##### (2)

jal 指令立即数有 20 位，bit0 默认为 0，范围为 [0xfff00000, 0x000ffffe]，所以可到达 0x0CF00000~0x0D0FFFFE

blt 指令立即数有 12 位，bit0 默认为 0，范围为 [0xfffff000, 0x00000ffe]，所以可到达 0x0CFFF000~0x0D000FFE

注：跳转是非连续的，按两字节对齐。上面只是表示范围，范围内的地址不一定能直接到达。

### T2

> 本题目中所述的 int 整型变量都是 32 位的。 
>
> 1. 将 −a ∗ 2 − (b + c) − (d + b + c) + 200 转换为 RV32I 指令（a, b, c, d 均为 int 整型数值，且已经分别保留在寄存器 t0, t1, t2, t3 中。不考虑溢出问题）。请尝试使用尽可能少的寄存器和尽可能少的指令。 
> 2. 将 A[2 ∗ j] = B[i − 8] 转换为 RV32I 指令，其中 A, B 为 int 整型数组。它们的基址分别保存在寄存器 a0, a1 中。 i, j 均为 int 整型变量，且已保存在寄存器 t0, t1 中（不考虑溢出以及非法访问问题，所有数据都已经四字节对齐）。 尽可能为你的指令添加注释，使得助教能够更好的理解你的代码。

##### (1)

```assembly
add t0, t0, t0; #t0=a*2=a+a
add t1, t1, t2; #t1=b+c
add t2, t1, t3; #t2=d+b+c=d+t1
andi t3, t3, x0; #t3=0
add t3, t3, t0; #t3=-a*2
add t3, t3, t1; #t3=-a*2-(b+c)
add t3, t3, t2; #t3=-a*2-(b+c)-(d+b+c)
addi t3, t3, 200; #t3=-a*2-(b+c)-(d+b+c)+200
```

##### (2)

```assembly
subi t0, t0, 8; #t0=i-8
add t1, t1, t1; #t1=2*j
slli t0, t0, 2; #t0=t0*4
slli t1, t1, 2; #t1=t1*4
add a0, a0, t1; #a0=&A[2*j]
add a1, a1, t0; #a1=&B[i-8]
lw t2, 0(a1); #t2=B[i-8]
sw t2, 0(a0); #A[2*j]=B[i-8]
```

### T3

> 我们知道 RISC-V 存储是小端序的，即低地址存储低位，高地址存储高位。阅读如下代码： 
>
> ```assembly
> lb t1, 1(t0); 
> sw t1, 4(t0); 
> ```
>
> 初始条件下，t0 的内容为 0x2023, 地址 0x2023 的内容为 0x20881124。请问: 
>
> 1. 该代码执行后，地址 0x202A 的内容是什么？ 
> 2. 如果 RISC-V 是大端序存储的，那么该代码执行后，地址 0x202A 的内容是什么？

##### (1)

t1 = 0x00000011

M[0x2027] = 0x00000011

M[0x202A] = 0x00

##### (2)

M[0x202A] = 0x88

### T4

> 现在我们需要使用 RV32I 指令求解斐波那契数列的前 n 项，其中 n 为 int 整型变量，保存在内存地址 place 中。斐波那契数列的第一项和第二项分别保存在内存地址 first 和 second 中。请根据以上信息编写 RV32I 指令，将从第一项开始的结果依次保存在从内存地址 save 开始的连续内存中。

```assembly
la t0, place; #t0=place
lw t1, 0(t0); #t1=n
beqz t1, done; #n==0? done: keep
la t2, save; #t2=save
la t3, first; #t3=first
lw t3, 0(t3); #t3=f(1)
sw t3, 0(t2); #save f(1)
subi t1, t1, 1; #n--
beqz t1, done; #n==1? done: keep
addi t2, t2, 4; #指向下个储存位置
la t4, second; #t4=second
lw t4, 0(t4); #t4=f(2)
sw t4, 0(t2); #save f(2)
subi t1, t1, 1; #n--
beqz t1, done; #n==2? done: keep
loop: add t4, t4, t3; #t4=f(n)=f(n-1)+f(n-2)
sub t3, t4, t3; #t3=f(n-1)
addi t2, t2, 4; #指向下个储存位置
sw t4, 0(t2); #save f(n)
subi t1, t1, 1; #n--
bgtz t1, loop; #n>0? keep: done
done: #结束程序
```

#### 实验题1

已提交